<?php
 require_once('dm-utils.inc.php'); class ConvolutionCoding { private $iSpec = array(); private $iGenMat = array(); private $iName = ''; private $iHeader = 0; private $iDebugPrintLevel = 0; function ConvolutionCoding($aOutputBits,$aInputBits,$aNumShifts,&$aGenMat,$aName,$aHeader) { $this->iSpec = array($aOutputBits,$aInputBits,$aNumShifts); $this->iGenMat = $aGenMat; $this->iName = $aName; $this->iHeader = $aHeader; } function _genOutput($aMem) { $v = array(); for($i=0; $i < $this->iSpec[0]; ++$i ) { $sum=0; for($j=0; $j < $this->iSpec[1]; ++$j ) { $n = $this->iSpec[2]+1; for($k=0; $k < $n; ++$k ) { $sum ^= $this->iGenMat[$i][$j*$n + $k] * $aMem[$j][$k]; } } $v[$i] = $sum; } return $v; } function GetHeader() { return array_reverse(str_split($this->iHeader)); } function Get($aData) { $bits = array(); ByteArray2Bits($aData,$bits); return $this->_Get($bits); } function UnitTestInfo($aTxt,$aLevel=1) { if( $aLevel <= $this->iDebugPrintLevel ) echo $aTxt; } function _Get($aDataBits,&$outputBits,$aAddFlushBits=true) { $totInputBits = count($aDataBits); if( $totInputBits % $this->iSpec[1] ) { $padBits = $this->iSpec[1] - ($totInputBits % $this->iSpec[1]); for($i=0; $i < $padBits; ++$i ) { $aDataBits[$totInputBits+$i] = 0; } $totInputBits += $padBits; echo "Adding $padBits pad bits\n"; } $nbrLoops = $totInputBits / ($this->iSpec[1]); $bitIndex = 0; $outputBitIndex = 0; $outputBits = array(); if( $aAddFlushBits ) { $m = $this->iSpec[1]*$this->iSpec[2]; $this->UnitTestInfo("Adding $m flush bits\n"); for( $i=$totInputBits; $i < $totInputBits+$m; ++$i ) { $aDataBits[$i] = 0; } $totInputBits += $m; $nbrLoops = $totInputBits / ($this->iSpec[1]); } for($m=0; $m < $this->iSpec[1]; ++$m ) { for($n=0; $n < $this->iSpec[2]+1; ++$n ) { $u[$m][$n] = 0; } } for( $i=0; $i < $nbrLoops; ++$i ) { for($j=0; $j < $this->iSpec[1]; ++$j ) { $u[$j][0] = $aDataBits[$bitIndex++]; } $v = $this->_genOutput($u); for($j=0; $j < $this->iSpec[0]; ++$j ) { $outputBits[$outputBitIndex++] = $v[$j]; } for($j=0; $j < $this->iSpec[1]; ++$j ) { for($k=$this->iSpec[2]; $k > 0 ; --$k ) { $u[$j][$k] = $u[$j][$k-1]; } } for($j=0; $j < $this->iSpec[1]; ++$j ) { $u[$j][1] = $u[$j][0]; } } } } class ECC_050 extends ConvolutionCoding { function ECC_050() { $genMat = array( array(1,0,0,0, 0,0,0,1, 0,1,1,1), array(0,0,1,1, 1,1,0,1, 0,0,0,0), array(0,1,1,1, 0,1,0,0, 1,1,0,0), array(1,1,0,0, 1,1,1,0, 1,1,0,1), ); parent::ConvolutionCoding(4,3,3,$genMat,'ECC_050','0001110000000001110'); } } class ECC_080 extends ConvolutionCoding { function ECC_080() { $genMat = array( array(1,1,0,2,0,1,1,1,0,0,1,0, 0,0,0,1,0,0,0,1,1,0,0,1), array(0,1,0,0,1,1,0,0,1,1,1,0, 1,0,0,1,0,0,1,0,1,1,0,0), array(1,0,0,0,0,1,1,1,0,0,0,0, 1,1,1,0,1,0,0,1,0,1,0,1) ); parent::ConvolutionCoding(3,2,11,$genMat,'ECC_080','1110001110000001110'); } } class ECC_100 extends ConvolutionCoding { function ECC_100() { $genMat = array( array(1,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1), array(1,1,0,1,1,0,1,0,0,0,0,1,0,1,1,1) ); parent::ConvolutionCoding(2,1,15,$genMat,'ECC_100','1111111110000001110'); } } class ECC_140 extends ConvolutionCoding { function ECC_140() { $genMat = array( array(1,0,0,0,1,0,0,1,0,0,1,0,1,1), array(1,0,0,1,1,0,0,1,1,1,1,1,0,1), array(1,1,1,0,1,1,0,1,0,1,0,1,1,1), array(1,1,1,0,1,1,0,1,0,1,1,1,1,1) ); parent::ConvolutionCoding(4,1,13,$genMat,'ECC_140','1111110001110001110'); } } class ECC_NONE { private $iHeader = '1111110'; function Get($aData) { $bits = array(); ByteArray2Bits($aData,$bits); return $bits; } function GetHeader() { return array_reverse(str_split($this->iHeader)); } function _Get($aInputBits,&$aOutputBits) { $aOutputBits = $aInputBits; } } DEFINE("ECC_NONE",0); DEFINE("ECC_050",1); DEFINE("ECC_080",2); DEFINE("ECC_100",3); DEFINE("ECC_140",4); class ECC_Factory { function Create($aCode) { $names = array("NONE","050","080","100","140"); $className = 'ECC_'.$names[$aCode]; return new $className; } } ?>
